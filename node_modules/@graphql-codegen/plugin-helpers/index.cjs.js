'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const path = _interopDefault(require('path'));
const fs = _interopDefault(require('fs'));
const importFrom = _interopDefault(require('import-from'));
const changeCase = require('change-case');
const graphql = require('graphql');
const common = require('@graphql-toolkit/common');

function resolveExternalModuleAndFn(pointer) {
    if (typeof pointer === 'function') {
        return pointer;
    }
    const patternArr = pointer.split('#');
    const moduleName = patternArr[0];
    const functionName = patternArr[1];
    const localFilePath = path.resolve(process.cwd(), moduleName);
    const localFileExists = fs.existsSync(localFilePath);
    const loadedModule = localFileExists ? require(localFilePath) : importFrom(process.cwd(), moduleName);
    if (!(functionName in loadedModule)) {
        throw new Error(`${functionName} couldn't be found in module ${moduleName}!`);
    }
    return loadedModule[functionName];
}

function toPascalCase(str) {
    if (str.charAt(0) === '_') {
        return str.replace(/^(_*)(.*)/, (_match, underscorePrefix, typeName) => `${underscorePrefix}${changeCase.pascalCase(typeName || '')}`);
    }
    return changeCase.pascalCase(str || '');
}

function isComplexPluginOutput(obj) {
    return typeof obj === 'object' && obj.hasOwnProperty('content');
}

function mergeOutputs(content) {
    let result = { content: '', prepend: [], append: [] };
    if (Array.isArray(content)) {
        content.forEach(item => {
            if (typeof item === 'string') {
                result.content += item;
            }
            else {
                result.content += item.content;
                result.prepend.push(...(item.prepend || []));
                result.append.push(...(item.append || []));
            }
        });
    }
    return [...result.prepend, result.content, ...result.append].join('\n');
}
function isWrapperType(t) {
    return graphql.isListType(t) || graphql.isNonNullType(t);
}
function getBaseType(type) {
    if (isWrapperType(type)) {
        return getBaseType(type.ofType);
    }
    else {
        return type;
    }
}

function isOutputConfigArray(type) {
    return Array.isArray(type);
}
function isConfiguredOutput(type) {
    return typeof type === 'object' && type['plugins'];
}
function normalizeOutputParam(config) {
    // In case of direct array with a list of plugins
    if (isOutputConfigArray(config)) {
        return {
            documents: [],
            schema: [],
            plugins: config,
        };
    }
    else if (isConfiguredOutput(config)) {
        return config;
    }
    else {
        throw new Error(`Invalid "generates" config!`);
    }
}
function normalizeInstanceOrArray(type) {
    if (Array.isArray(type)) {
        return type;
    }
    else if (!type) {
        return [];
    }
    return [type];
}
function normalizeConfig(config) {
    if (typeof config === 'string') {
        return [{ [config]: {} }];
    }
    else if (Array.isArray(config)) {
        return config.map(plugin => (typeof plugin === 'string' ? { [plugin]: {} } : plugin));
    }
    else if (typeof config === 'object') {
        return Object.keys(config).reduce((prev, pluginName) => [...prev, { [pluginName]: config[pluginName] }], []);
    }
    else {
        return [];
    }
}
function hasNullableTypeRecursively(type) {
    if (!graphql.isNonNullType(type)) {
        return true;
    }
    if (graphql.isListType(type) || graphql.isNonNullType(type)) {
        return hasNullableTypeRecursively(type.ofType);
    }
    return false;
}
function isUsingTypes(document, externalFragments, schema) {
    let foundFields = 0;
    let typesStack = [];
    graphql.visit(document, {
        InlineFragment: {
            enter: (node) => {
                if (node.typeCondition && schema) {
                    typesStack.push(schema.getType(node.typeCondition.name.value));
                }
            },
            leave: (node) => {
                if (node.typeCondition && schema) {
                    typesStack.pop();
                }
            },
        },
        Field: {
            enter: (node, key, parent, path, anscestors) => {
                if (node.name.value.startsWith('__')) {
                    return;
                }
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                if (schema) {
                    const lastType = typesStack[typesStack.length - 1];
                    if (lastType) {
                        if (graphql.isObjectType(lastType)) {
                            const field = lastType.getFields()[node.name.value];
                            if (!field) {
                                throw new Error(`Unable to find field "${node.name.value}" on type "${lastType}"!`);
                            }
                            const currentType = field.type;
                            // To handle `Maybe` usage
                            if (hasNullableTypeRecursively(currentType)) {
                                foundFields++;
                            }
                            typesStack.push(getBaseType(currentType));
                        }
                    }
                }
                const selections = node.selectionSet ? node.selectionSet.selections || [] : [];
                const relevantFragmentSpreads = selections.filter(s => s.kind === graphql.Kind.FRAGMENT_SPREAD && !externalFragments.includes(s.name.value));
                if (selections.length === 0 || relevantFragmentSpreads.length > 0) {
                    foundFields++;
                }
            },
            leave: (node, key, parent, path, anscestors) => {
                if (node.name.value.startsWith('__')) {
                    return;
                }
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                if (schema) {
                    const currentType = typesStack[typesStack.length - 1];
                    if (currentType && graphql.isObjectType(currentType)) {
                        typesStack.pop();
                    }
                }
            },
        },
        FragmentDefinition: {
            enter: (node) => {
                if (schema) {
                    typesStack.push(schema.getType(node.typeCondition.name.value));
                }
            },
            leave: () => {
                if (schema) {
                    typesStack.pop();
                }
            },
        },
        OperationDefinition: {
            enter: (node) => {
                if (schema) {
                    if (node.operation === 'query') {
                        typesStack.push(schema.getQueryType());
                    }
                    else if (node.operation === 'mutation') {
                        typesStack.push(schema.getMutationType());
                    }
                    else if (node.operation === 'subscription') {
                        typesStack.push(schema.getSubscriptionType());
                    }
                }
            },
            leave: () => {
                if (schema) {
                    typesStack.pop();
                }
            },
        },
        enter: {
            VariableDefinition: (node, key, parent, path, anscestors) => {
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                foundFields++;
            },
            InputValueDefinition: (node, key, parent, path, anscestors) => {
                const insideIgnoredFragment = anscestors.find((f) => f.kind && f.kind === 'FragmentDefinition' && externalFragments.includes(f.name.value));
                if (insideIgnoredFragment) {
                    return;
                }
                foundFields++;
            },
        },
    });
    return foundFields > 0;
}

/**
 * Federation Spec
 */
const federationSpec = graphql.parse(/* GraphQL */ `
  scalar _FieldSet

  directive @external on FIELD_DEFINITION
  directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
  directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
  directive @key(fields: _FieldSet!) on OBJECT | INTERFACE
`);
/**
 * Adds `__resolveReference` in each ObjectType involved in Federation.
 * @param schema
 */
function addFederationReferencesToSchema(schema) {
    const doc = graphql.parse(common.printSchemaWithDirectives(schema));
    const visited = graphql.visit(doc, {
        ObjectTypeDefinition(node) {
            if (!isFederationObjectType(node)) {
                return node;
            }
            return {
                ...node,
                fields: [
                    {
                        kind: graphql.Kind.FIELD_DEFINITION,
                        name: {
                            kind: graphql.Kind.NAME,
                            value: resolveReferenceFieldName,
                        },
                        type: {
                            kind: graphql.Kind.NAMED_TYPE,
                            name: {
                                kind: graphql.Kind.NAME,
                                value: node.name.value,
                            },
                        },
                        arguments: [],
                    },
                    ...node.fields,
                ],
            };
        },
    });
    return graphql.buildASTSchema(visited, {
        assumeValidSDL: true,
    });
}
/**
 * Turns ObjectType extensions into ObjectTypes
 * @param ast Schema AST
 */
function turnExtensionsIntoObjectTypes(ast) {
    return {
        ...ast,
        definitions: ast.definitions.map(def => {
            if (def.kind !== graphql.Kind.OBJECT_TYPE_EXTENSION) {
                return def;
            }
            const isDefined = ast.definitions.some(d => d.kind === graphql.Kind.OBJECT_TYPE_DEFINITION && d.name.value === def.name.value);
            if (isDefined) {
                return def;
            }
            return {
                ...def,
                kind: graphql.Kind.OBJECT_TYPE_DEFINITION,
            };
        }),
    };
}
/**
 * Removes Federation Spec from GraphQL Schema
 * @param schema
 * @param config
 */
function removeFederation(schema, { withDirectives, }) {
    const queryTypeName = schema.getQueryType().name;
    const printedSchema = withDirectives ? common.printSchemaWithDirectives(schema) : graphql.printSchema(schema);
    const astNode = graphql.parse(printedSchema);
    const emptyNode = null;
    const docWithoutFederation = graphql.visit(astNode, {
        ScalarTypeDefinition(node) {
            if (node.name.value === '_Any') {
                return emptyNode;
            }
            return node;
        },
        UnionTypeDefinition(node) {
            if (node.name.value === '_Entity') {
                return emptyNode;
            }
            return node;
        },
        ObjectTypeDefinition(node) {
            if (node.name.value === '_Service') {
                return emptyNode;
            }
            if (node.name.value === queryTypeName) {
                return {
                    ...node,
                    fields: node.fields.filter(field => ['_entities', '_service'].includes(field.name.value) === false),
                };
            }
            return node;
        },
    });
    return graphql.buildASTSchema(docWithoutFederation, {
        commentDescriptions: false,
    });
}
const resolveReferenceFieldName = '__resolveReference';
class ApolloFederation {
    constructor({ enabled, schema }) {
        this.enabled = false;
        this.enabled = enabled;
        this.schema = schema;
        this.providesMap = this.createMapOfProvides();
    }
    /**
     * Excludes types definde by Federation
     * @param typeNames List of type names
     */
    filterTypeNames(typeNames) {
        return this.enabled ? typeNames.filter(t => t !== '_FieldSet') : typeNames;
    }
    /**
     * Excludes `__resolveReference` fields
     * @param fieldNames List of field names
     */
    filterFieldNames(fieldNames) {
        return this.enabled ? fieldNames.filter(t => t !== resolveReferenceFieldName) : fieldNames;
    }
    /**
     * Decides if directive should not be generated
     * @param name directive's name
     */
    skipDirective(name) {
        return this.enabled && ['external', 'requires', 'provides', 'key'].includes(name);
    }
    /**
     * Decides if scalar should not be generated
     * @param name directive's name
     */
    skipScalar(name) {
        return this.enabled && name === '_FieldSet';
    }
    /**
     * Decides if field should not be generated
     * @param data
     */
    skipField({ fieldNode, parentType }) {
        if (!this.enabled || !graphql.isObjectType(parentType) || !isFederationObjectType(parentType)) {
            return false;
        }
        return this.isExternalAndNotProvided(fieldNode, parentType);
    }
    isResolveReferenceField(fieldNode) {
        const name = typeof fieldNode.name === 'string' ? fieldNode.name : fieldNode.name.value;
        return this.enabled && name === resolveReferenceFieldName;
    }
    /**
     * Transforms ParentType signature in ObjectTypes involved in Federation
     * @param data
     */
    transformParentType({ fieldNode, parentType, parentTypeSignature }) {
        if (this.enabled && graphql.isObjectType(parentType) && isFederationObjectType(parentType) && fieldNode.name.value === resolveReferenceFieldName) {
            const keys = getDirectivesByName('key', parentType);
            if (keys.length) {
                const outputs = [`{ __typename: '${parentType.name}' } &`];
                // Look for @requires and see what the service needs and gets
                const requires = getDirectivesByName('requires', fieldNode)
                    .map(this.extractFieldSet)
                    .reduce((prev, curr) => [...prev, ...curr], [])
                    .map(name => {
                    return { name, required: graphql.isNonNullType(parentType.getFields()[name].type) };
                });
                const requiredFields = this.translateFieldSet(requires, parentTypeSignature);
                // @key() @key() - "primary keys" in Federation
                const primaryKeys = keys.map(def => {
                    const fields = this.extractFieldSet(def).map(name => ({ name, required: true }));
                    return this.translateFieldSet(fields, parentTypeSignature);
                });
                const [open, close] = primaryKeys.length > 1 ? ['(', ')'] : ['', ''];
                outputs.push([open, primaryKeys.join(' | '), close].join(''));
                // include required fields
                if (requires.length) {
                    outputs.push(`& ${requiredFields}`);
                }
                return outputs.join(' ');
            }
        }
        return parentTypeSignature;
    }
    isExternalAndNotProvided(fieldNode, objectType) {
        return this.isExternal(fieldNode) && !this.hasProvides(objectType, fieldNode);
    }
    isExternal(node) {
        return getDirectivesByName('external', node).length > 0;
    }
    hasProvides(objectType, node) {
        const fields = this.providesMap[graphql.isObjectType(objectType) ? objectType.name : objectType.name.value];
        if (fields && fields.length) {
            return fields.includes(node.name.value);
        }
        return false;
    }
    translateFieldSet(fields, parentTypeRef) {
        // TODO: support other things than fields separated by a whitespace (fields: "fieldA fieldB fieldC")
        const keys = fields.map(field => `'${field.name}'`).join(' | ');
        return `Pick<${parentTypeRef}, ${keys}>`;
    }
    extractFieldSet(directive) {
        const arg = directive.arguments.find(arg => arg.name.value === 'fields');
        const value = arg.value.value;
        if (/[\{\}]+/gi.test(value)) {
            throw new Error('Nested fields in _FieldSet is not supported');
        }
        return deduplicate(value.split(/\s+/g));
    }
    createMapOfProvides() {
        const providesMap = {};
        Object.keys(this.schema.getTypeMap()).forEach(typename => {
            const objectType = this.schema.getType(typename);
            if (graphql.isObjectType(objectType)) {
                Object.values(objectType.getFields()).forEach(field => {
                    const provides = getDirectivesByName('provides', field.astNode)
                        .map(this.extractFieldSet)
                        .reduce((prev, curr) => [...prev, ...curr], []);
                    const ofType = getBaseType(field.type);
                    if (!providesMap[ofType.name]) {
                        providesMap[ofType.name] = [];
                    }
                    providesMap[ofType.name].push(...provides);
                });
            }
        });
        return providesMap;
    }
}
/**
 * Checks if Object Type is involved in Federation. Based on `@key` directive
 * @param node Type
 */
function isFederationObjectType(node) {
    const name = graphql.isObjectType(node) ? node.name : node.name.value;
    const directives = graphql.isObjectType(node) ? node.astNode.directives : node.directives;
    const isNotRoot = !['Query', 'Mutation', 'Subscription'].includes(name);
    const isNotIntrospection = !name.startsWith('__');
    const hasKeyDirective = directives.some(d => d.name.value === 'key');
    return isNotRoot && isNotIntrospection && hasKeyDirective;
}
function deduplicate(items) {
    return items.filter((item, i) => items.indexOf(item) === i);
}
/**
 * Extracts directives from a node based on directive's name
 * @param name directive name
 * @param node ObjectType or Field
 */
function getDirectivesByName(name, node) {
    let astNode;
    if (graphql.isObjectType(node)) {
        astNode = node.astNode;
    }
    else {
        astNode = node;
    }
    if (astNode && astNode.directives) {
        return astNode.directives.filter(d => d.name.value === name);
    }
    return [];
}

exports.ApolloFederation = ApolloFederation;
exports.addFederationReferencesToSchema = addFederationReferencesToSchema;
exports.federationSpec = federationSpec;
exports.getBaseType = getBaseType;
exports.hasNullableTypeRecursively = hasNullableTypeRecursively;
exports.isComplexPluginOutput = isComplexPluginOutput;
exports.isConfiguredOutput = isConfiguredOutput;
exports.isOutputConfigArray = isOutputConfigArray;
exports.isUsingTypes = isUsingTypes;
exports.isWrapperType = isWrapperType;
exports.mergeOutputs = mergeOutputs;
exports.normalizeConfig = normalizeConfig;
exports.normalizeInstanceOrArray = normalizeInstanceOrArray;
exports.normalizeOutputParam = normalizeOutputParam;
exports.removeFederation = removeFederation;
exports.resolveExternalModuleAndFn = resolveExternalModuleAndFn;
exports.toPascalCase = toPascalCase;
exports.turnExtensionsIntoObjectTypes = turnExtensionsIntoObjectTypes;
