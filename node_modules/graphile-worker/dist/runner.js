"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const pg_1 = require("pg");
const getTasks_1 = require("./getTasks");
const main_1 = require("./main");
const helpers_1 = require("./helpers");
const migrate_1 = require("./migrate");
const logger_1 = require("./logger");
async function assertTaskList(options, releasers) {
    let taskList;
    assert(!options.taskDirectory || !options.taskList, "Exactly one of either `taskDirectory` or `taskList` should be set");
    if (options.taskList) {
        taskList = options.taskList;
    }
    else if (options.taskDirectory) {
        const watchedTasks = await getTasks_1.default(options.taskDirectory, false);
        releasers.push(() => watchedTasks.release());
        taskList = watchedTasks.tasks;
    }
    else {
        throw new Error("You must specify either `options.taskList` or `options.taskDirectory`");
    }
    return taskList;
}
async function assertPool(options, releasers, logger) {
    assert(!options.pgPool || !options.connectionString, "Both `pgPool` and `connectionString` are set, at most one of these options should be provided");
    let pgPool;
    if (options.pgPool) {
        pgPool = options.pgPool;
    }
    else if (options.connectionString) {
        pgPool = new pg_1.Pool({ connectionString: options.connectionString });
        releasers.push(() => pgPool.end());
    }
    else if (process.env.DATABASE_URL) {
        pgPool = new pg_1.Pool({ connectionString: process.env.DATABASE_URL });
        releasers.push(() => pgPool.end());
    }
    else {
        throw new Error("You must either specify `pgPool` or `connectionString`, or you must make the `DATABASE_URL` environmental variable available.");
    }
    pgPool.on("error", err => {
        /*
         * This handler is required so that client connection errors don't bring
         * the server down (via `unhandledError`).
         *
         * `pg` will automatically terminate the client and remove it from the
         * pool, so we don't actually need to take any action here, just ensure
         * that the event listener is registered.
         */
        logger.error(`PostgreSQL client generated error: ${err.message}`, {
            error: err,
        });
    });
    return pgPool;
}
async function withReleasers(callback) {
    const releasers = [];
    const release = async () => {
        await Promise.all(releasers.map(fn => fn()));
    };
    try {
        return await callback(releasers, release);
    }
    catch (e) {
        try {
            await release();
        }
        catch (e2) {
            /* noop */
        }
        throw e;
    }
}
const processOptions = async (options) => {
    const { logger = logger_1.defaultLogger } = options;
    return withReleasers(async (releasers, release) => {
        const taskList = await assertTaskList(options, releasers);
        const pgPool = await assertPool(options, releasers, logger);
        const withPgClient = helpers_1.makeWithPgClientFromPool(pgPool);
        // Migrate
        await withPgClient(client => migrate_1.migrate(client));
        return { taskList, pgPool, withPgClient, release, logger };
    });
};
exports.runMigrations = async (options) => {
    const { logger = logger_1.defaultLogger } = options;
    return withReleasers(async (releasers, release) => {
        const pgPool = await assertPool(options, releasers, logger);
        const withPgClient = helpers_1.makeWithPgClientFromPool(pgPool);
        // Migrate
        await withPgClient(client => migrate_1.migrate(client));
        await release();
        return;
    });
};
exports.runOnce = async (options) => {
    const { taskList, withPgClient, release } = await processOptions(options);
    await withPgClient(client => main_1.runTaskListOnce(taskList, client, options));
    await release();
};
exports.run = async (options) => {
    const { taskList, pgPool, withPgClient, release } = await processOptions(options);
    const workerPool = main_1.runTaskList(taskList, pgPool, options);
    let running = true;
    return {
        async stop() {
            if (running) {
                throw new Error("Runner is already stopped");
            }
            else {
                running = false;
                await workerPool.release();
                await release();
            }
        },
        addJob: helpers_1.makeAddJob(withPgClient),
        promise: workerPool.promise,
    };
};
//# sourceMappingURL=runner.js.map